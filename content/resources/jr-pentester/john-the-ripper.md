---
title: "John the Ripper"
date: 2024-01-20
---

# John the Ripper
- John the Ripper is a well-known, well-loved, and versatile hash-cracking tool. It combines a fast cracking speed with an extraordinary range of compatible hash types.

## Basics
- `Hash`: A hash is a way of taking a piece of data of any length and representing it in another fixed-length form. This process masks the original value of the data. The hash value is obtained by running the original data through a hashing algorithm. Many popular hashing algorithms exist, such as MD4, MD5, SHA1 and NTLM. Let’s try and show this with an example:

- `What Makes Hashes Secure?`: Hashing functions are designed as one-way functions. In other words, it is easy to calculate the hash value of a given input; however, it is a hard problem to find the original input given the hash value. I

- `Where the John Comes in`: Even though the algorithm is not feasibly reversible, that doesn’t mean cracking the hashes is impossible. Lets see the below example called as **dictionary attack**: 
    1. If you have the hashed version of a password, for example, and you know the hashing algorithm, you can use that hashing algorithm to hash a large number of words, called a dictionary. 
    2. You can then compare these hashes to the one you’re trying to crack to see if they match. If they do, you know what word corresponds to that hash- you’ve cracked it!

- Throughout this document, we will be using the following `Jumbo John` extended version of `john`. Its already preinstalled in the Kali. 


## Cracking Basic Hashes
#### John Basic syntax
- The very basic syntax of the `John the Ripper` is as follow
  `john [options] [file_path]`

#### Automatic cracking
- John has built in features to detect what type of hash its being given ans to select appropriate rules and formats to crack it for you.
- This is not always a best idea as it can be unreliable, but if you cant identify the hash type youre working with and try crackingit, it can be a good option.   
  `john --wordlist=/usr/share/wordlist/rockyou.txt hash_to_crack.txt`

#### identifying Hashes
- Sometimes, john wont play nicely with the auto recognizing and loading hashes, but that's okay.
- We can use other tools to identify the hash and then set the john specific format. For example, [Hash Identifier](https://gitlab.com/kalilinux/packages/hash-identifier/-/tree/kali/master), a python tool that is super easy to use and will tell you what different types of hashes the one you enter is likey to be, giving more options if the first one fails.  
- To use `Hash identifier` we use wget or curl to download the python file `hash-id.py` from the github page.  
  `wget https://gitlab.com/kalilinux/packages/hash-identifier/-/raw/kali/master/hash-id.py`
- Then, launch it with python3 hash-id.py and enter the hash you’re trying to identify. 


#### Format specific cracking
- Once we identified hash type, tell john to use to it.
  `john --format=<format> --wordlist=<wordlist_path> <hash_file_path>`
- To list the available formats
  `john --list=formats


## Cracking Windows Authentication Hashes
- Authentication hashes are hashed version of password stored by OS, it is sometimes possible to crack them using our brute-force methods. To get your hands on these hashes, you mush be already a privilaged user. 
#### NTHash/NTLM
- `NThash` is the hash format modern  windows os machines use to store user and service passwords. Its also commonly referred to as NTLM, which references the previous version of windows format for hashing passwords known as LM, thus New Techology LM (NT/LM).
- In windows, SAM (security  account manager) is used to store user account information, including usernames and hashed passwords. You can acuire NTLM hashes by dumping the SAM database on a windows machine, using a tool like MimiKatz, or using Active Directory Datebase: NTDS.dit.
- Practical, use the same methods we learnt above to crack the ntlm.txt file.

## Cracking hashes form /etc/shadows
- The `/etc/shadow` is a file on linux machines where password hashes are stored. It also stores other information, such as the date of last password change and password expiration information. 
#### Unshadowing
- John can be very particular about the formats it needs data in to be able to work with it; for this reason, to crack `/etc/shadow`  passwords, you must combine it with the `/etc/passwd` for john to understand the data its being given.
- To do this, we use a tool built into the john suit of tools called `unshadow`. 
- The basic syntax of `unshadow` is as follows:  
  `unshadow <path_to_passwd_file> <path_to_shadow_file>`
- Example usage:   
  `unshadow local_passwd local_shadow > unshadowed.txt`

#### Cracking
- We can then feed the output from `unshadow`, in our example `unshadowed.txt`, directly into the John. In some cases, we supposed to specify the format `--format=sha512crypt`.     
  `john --wordlist=/usr/share/wordlist/rockyou.txt --format=sha512crypt unshadowed.txt`


## Single Crack mode
- So far, we've been using john's wordlist mode to brute-force simple and not-so-simpel hashes. But john also has another mode, called the `Single crack` mode.
- In this mode, John uses only the information provided in the username to try and work out possible passowords heuristically by slightly changing the letters and numbers contained with in username.
#### Word Mangling
- The best way to explain `Single crack` mode and word mangling is to go through the example
  - consider the username `Markus`
  - some possbile passwords could be
    ```
    Markus1, Markus2, Markus3 ...
    MArkus, MARkus, MARKus ...
    Markus!, Markus$, Markus* ..
    ```
  - John is building its dictionary based on the information it has been fed and uses a set of rules called `mangling rules`, which define how it can mutate the word it started with to generate a wordlist based on relevant factors for the target you're trying to crack. This exploits how poor passwords can be based on information about  the username or the service they're logging into.
#### GECOS
- John's implemetion of word mangling also features compatibity with the GECOS field of the UNIX OS, as well as other UNIX like OS.
- GECOS - General Electric Comprehensive OS
- In the last task, we looked at entries for both `/etc/shadow` and `/etc/passwd`. 
- Looking closely you will notice that the fields are seperated by a colon `:`. The fifth field in the user account record is the GECOS field. It stores general information about the user, such as the user's full name, office number, and telephone number, and among other things.
- John can take information stored in those records, such as full name, home directory name, to add to the wordlist it generates when cracking `/etc/shadow` hashes with single cracking mode.
  
#### Using single cracking mode
- To use this mode, we use roughly the same sytax that we've used so far.
  `john --single --format=<format> <path_to_file>`
- Example:
  `john --single --format=raw-sha256 hashes.txt`

- if you are cracking hashes on single check mode, you need to change the file format that you feeding John for it to understand what data to create a wordlist from. YOu do this by preparing the hash with username that the hash belongs to, so according to the above example, we would change the file `hashes.txt`
    ```bash
    cat hashes.txt
    mike:1efee03cdcb96d90ad48ccc7b8666033
    ```


## Custome Rules
- You can define your rules, which john  will use to create passwords dynamically. 
- The ability to define such rules is beneficial when you know more information about the password structure of whatever your target is.

#### Common Custom Rules
- Password complexity is good! However we can exploit the fact that most users will be prodictable in the location of these symbols. For the above criteria, many users will use something like following:
- Lets for user `Mike`, password most likely to be a `Mikepassowrd1!`
- Consider password with a capital letter first and a number followed by a symbol at the end. 
- This familiar pattern of the password, appended by modifiers (such as capital letters or numbers), is a memorable pattern that people use and reuse when creating passwords.
- This pattern can let us exploit password complexity predictability.
#### creating custom Rules
- Custom rules are usually defined in the `/etc/john/john.conf` if its installed form packege installer.
- Lets go over syntax of these custom rules, using the example above as our target pattern. 
- Note that you can define a massive level of granular control of these rules.
- I suggest looking at the wiki [here](https://www.openwall.com/john/doc/RULES.shtml) to get a full view of the modifiers you can use and more examples of rule implementation.
  ```bash
  #used to define the name of the rule, what we use to call this custom rule form cmdline.
  [List.Rules.PoloPassword]
  cAz"[0-9] [!£$%@]"

  #c -> capitalizes the first lettter
  #Az -> Appends to end of the word
  #[0-9] -> A number in the range 0-9
  #[!£$%@] -> The password is followed by one of these symbols
  ```
- We could tehn call this custom rule a John argument using `--rule=PoloPassword` flag.
- For exampele:   
  `john --wordlist=/usr/share/wordlist/rockyou.txt --rule=PoloPassword <path_to_hash_file>`


## Cracking password Protected Zip files
- We can use john to crack the password on password protected zip files by using `Zip2John` tool in the john suit.

#### Zip2John
- similarly to the `unshadow` tool we used previously, we will use the `zip2John` tool to convert the Zip files into a hash format john can understand and hopefully crack.
- Syntx as follows:    
  `zip2John [options] [zip file] > [output file]`
- Example:   
  `zip2John zipfile.zip > zip_hash.txt`

#### Cracking
- We're then able to take the file output form `zip2John` in our exmaple use case `zip_hash.txt`, and as we did with `unshadow`, feed it directly into John as we have made the input specifically for it.
  `john --wordlist=/usr/share/wordlist/rockyou.txt zip_hash.txt`


## Cracking password-protected RAR Archive
- Same as we followed of zip files
- first convert the rar files into a hash that john can understand.
  `rar2john rarfile.rar > rar_hash.txt`
- And then feed it to the john
  `john --wordlist=/usr/share/wordlist/rockyou.txt rar_hash.txt`



## Cracking SSH keys with John
- Lets explore one more use of John that comes up semi frequently in CTF challanges -- using john to crack the the SSH private key password of `id_rsa`.
#### SSH2John
- Who could have guessed it, another conversion tool?? Wel, thats working with John is all about.   
  `SSH2John id_rsa > id_rsa_hash.txt`
- Lets if he do not have SSH2John installed, we can use `python3  /usr/share/john/ssh2john.py`
  `python3 /usr/share/john/ssh2john.py id_rsa > id_rsa_hash.txt`
- And that;s it. we can feed to the john now
  `john --wordlist=/usr/share/wordlist/rockyou.txt id_rsa_hash.txt`




## Cracking password of GPG based encryption key
- lets say a plain file `credentials.gpg` is encrypted using the private key `tryhackme.asc`, and its again need the password to decryt, lets say
  ```bash
  gpg --import tryhackme.asc
  gpg --decrypt credentials.gpg # asks passowrd
  ```
- lets brute force it with john
  ```bash
  /usr/sbin/gpg2hash tryhackme.asc > hash
  john --format=gpg --wordlist=/usr/share/wordlist/rockyou.txt hash
  ```
















